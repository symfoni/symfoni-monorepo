import { debug } from "debug";
import { HardhatRuntimeEnvironment } from "hardhat/types";
import {
  CodeBlockWriter,
  OptionalKind,
  SourceFile,
  SyntaxKind,
  VariableDeclarationKind,
  VariableDeclarationStructure,
} from "ts-morph";
import { ReactComponent } from "./ReactComponent";
import { ContractContext, contractInterfaceName } from "./TsMorhProject";
const log = debug("hardhat:plugin:react");

export class ReactContext {
  private sourceFile: SourceFile;
  private readonly args: any;
  private readonly hre: HardhatRuntimeEnvironment;
  private readonly contractContexts: ContractContext[];
  private reactComponent?: ReactComponent;
  private componentName = "Symfoni";
  constructor(
    sourceFile: SourceFile,
    args: any,
    bre: HardhatRuntimeEnvironment,
    contractContext: ContractContext[]
  ) {
    this.hre = bre;
    this.args = args;
    this.sourceFile = sourceFile;
    this.contractContexts = contractContext;
  }

  async generate() {
    this.headers();
    this.imports();
    this.preComponentStatements();
    this.preComponentInterfaces();
    const reactComponent = this.createReactComponent();
    this.reactComponent = new ReactComponent(
      this.sourceFile,
      this.args,
      this.hre,
      this.contractContexts,
      reactComponent
    );
    this.reactComponent.generate();
    this.sourceFile.formatText();
  }

  private headers() {
    this.sourceFile.addStatements((writer) => {
      writer.write(
        `/* Autogenerated file. Do not edit manually. */
        /* tslint:disable */
        /* eslint-disable */`
      );
    });
  }
  private imports() {
    this.sourceFile.addImportDeclarations([
      {
        namedImports: ["providers", "Signer", "ethers"],
        moduleSpecifier: "ethers",
      },
      {
        namedImports: ["useEffect", "useState"],
        defaultImport: "React",
        moduleSpecifier: "react",
      },
      {
        namedImports: ["IProviderOptions"],
        defaultImport: "Web3Modal",
        moduleSpecifier: "web3modal",
      },
    ]);
    // Adding .replace(`\\`, `/`) for windows corrections
    this.contractContexts.forEach((contract) => {
      if (!contract.instance) {
        this.sourceFile.addImportDeclarations([
          {
            namedImports: [`${contract.typechainInstanceName}`],
            moduleSpecifier:
              "./" +
              contract.typechainInstance
                .replace(".d.ts", "")
                .replace(`\\`, `/`),
          },
          {
            namedImports: [`${contract.typechainFactoryName}`],
            moduleSpecifier:
              "./" +
              contract.typechainFactory.replace(".ts", "").replace(`\\`, `/`),
          },
        ]);
      }
    });
    // Handle WalletConnectV2
    if (this.hre.config.react.walletConnectV2) {
      if (this.hre.config.react.walletConnectV2.enable) {
        log(
          "WalletConnectV2 configuration found. Ensure @walletconnect/qrcode-modal & @symfoni/walletconnect-v2-ethers-signer is installed in Frontend."
        );
        this.sourceFile.addImportDeclaration({
          defaultImport: `${"WalletConnectQrcodeModal"}`,
          moduleSpecifier: `${"@walletconnect/qrcode-modal"}`,
        });
        this.sourceFile.addImportDeclaration({
          namedImports: ["SIGNER_EVENTS", "WalletConnectSigner"],
          moduleSpecifier: `${"@symfoni/walletconnect-v2-ethers-signer"}`,
        });
      }
    }

    // Handle web3modal providers
    if (this.hre.config.react.providerOptions) {
      for (const [providerName, providerOptions] of Object.entries(
        this.hre.config.react.providerOptions
      )) {
        if (providerName === "walletconnect") {
          log(
            "WalletConnect configuration found. Ensure @walletconnect/web3-provider is installed in Frontend."
          );
          this.sourceFile.addImportDeclaration({
            defaultImport: `${"WalletConnectProvider"}`,
            moduleSpecifier: `${"@walletconnect/web3-provider"}`,
          });
        }
      }
    }
  }

  private addConstStatment(
    declaration: OptionalKind<VariableDeclarationStructure>,
    exported = false
  ) {
    this.sourceFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      isExported: exported,
      declarations: [declaration],
    });
  }
  private preComponentStatements() {
    this.addConstStatment({
      name: "emptyContract",
      initializer: `{
          instance: undefined,
          factory: undefined
        }`,
    });
    this.addConstStatment({
      name: "defaultProvider",
      type: "providers.Provider | undefined",
      initializer: "undefined",
    });
    this.addConstStatment(
      {
        name: "ProviderContext",
        initializer:
          "React.createContext<[providers.Provider | undefined, React.Dispatch<React.SetStateAction<providers.Provider | undefined>>]>([defaultProvider, () => { }])",
      },
      true
    );
    this.addConstStatment({
      name: "defaultCurrentAddress",
      type: "string",
      initializer: `""`,
    });
    this.addConstStatment(
      {
        name: "CurrentAddressContext",
        initializer:
          "React.createContext<[string, React.Dispatch<React.SetStateAction<string>>]>([defaultCurrentAddress, () => { }])",
      },
      true
    );
    this.addConstStatment({
      name: "defaultSigner",
      type: "Signer | undefined",
      initializer: "undefined",
    });
    this.addConstStatment(
      {
        name: "SignerContext",
        initializer:
          "React.createContext<[Signer | undefined, React.Dispatch<React.SetStateAction<Signer | undefined>>]>([defaultSigner, () => { }])",
      },
      true
    );

    this.addConstStatment({
      name: `default${this.componentName}Context`,
      type: `${this.componentName}ContextInterface`,
      initializer: `{
        currentHardhatProvider: "",
        init: () => { throw Error("Symfoni context not initialized") },
        loading: false,
        messages: [],
        providers: []
      }`,
    });
    this.addConstStatment(
      {
        name: `${this.componentName}Context`,
        initializer: `React.createContext<${this.componentName}ContextInterface>(default${this.componentName}Context)`,
      },
      true
    );

    this.contractContexts.forEach((contract) => {
      this.addConstStatment(
        {
          name: `${contract.name}Context`,
          initializer: `React.createContext<${contractInterfaceName(
            contract
          )}>(emptyContract)`,
        },
        true
      );
    });
  }

  private preComponentInterfaces() {
    this.sourceFile.addInterface({
      name: this.componentName + "ContextInterface",
      isExported: true,
      properties: [
        {
          name: "init",
          type: `(provider?: string) => void`,
        },
        {
          name: "loading",
          type: `boolean`,
        },
        {
          name: "messages",
          type: `string[]`,
        },
        {
          name: "currentHardhatProvider",
          type: `string`,
        },
        {
          name: "providers",
          type: `string[]`,
        },
      ],
    });
    this.sourceFile.addInterface({
      name: this.componentName + "Props",
      isExported: true,
      properties: [
        {
          name: "autoInit",
          type: `boolean`,
          hasQuestionToken: true,
        },
        {
          name: "showLoading",
          type: `boolean`,
          hasQuestionToken: true,
        },
        {
          name: "loadingComponent",
          type: `React.ReactNode`,
          hasQuestionToken: true,
        },
      ],
    });
    this.contractContexts.forEach((contract) => {
      this.sourceFile.addInterface({
        name: contractInterfaceName(contract),
        isExported: true,
        properties: [
          {
            name: "instance",
            type: `${contract.typechainInstanceName}`,
            hasQuestionToken: contract.deploymentFile ? true : true, // REVIEW If we can instantiate provider before component is generate we can maybe remove this
          },
          {
            name: "factory",
            type: `${contract.typechainFactoryName}`,
            hasQuestionToken: true,
          },
        ],
      });
    });
  }

  private createReactComponent() {
    this.sourceFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      isExported: true,
      declarations: [
        {
          name: this.componentName,
          type: `React.FC<${this.componentName + "Props"}>`,
          initializer: `({
            showLoading = true,
            autoInit = true,
            ...props
          }) => {}`,
        },
      ],
    });
    const symfoniContextContextComponent = this.sourceFile.getVariableDeclarationOrThrow(
      this.componentName
    );
    const reactComponent = symfoniContextContextComponent.getInitializerIfKindOrThrow(
      SyntaxKind.ArrowFunction
    );

    return reactComponent;
  }
}
